"""
data structure
	this peer's metadata
	this peer's DL status

P2P msg handler 
	parse P2P msgs + match msg handler
	create response msgs
	
"""

class Peer: 
	def __init__(self, torrent, peer_id_ip_port): 
		
		## peer metadata
		self.ip = ""
		self.port = None
		self.peer_id = None
		self.torrent = torrent ## torrent object
		self.info_hash = None
		self.peer_id_ip_port = init_from_Tracker_Response(peer_id_ip_port) ## {peer_id, ip, port} 
		self.handshake_exchanged = False
		
		## this peer DL status
		self.bitfield = bitarray(endian="big") ## downloaded pieces from this peer		
		self.received_message_buffer = [] ## received pieces from this peer
		self.outgoing_messages_buffer = [] ## outgoing Request Msg to this peer
		self.request_buffer = [] ## outstanding Request Msg -> redundant to self.outgoing_messages_buffer
		self.previous_requests = [] ## history of all previous Request Msg
		self.time_of_last_message = time.time() ## heartbeat		
		self.current_piece = None ## 1 peer send 1 piece at 1 time
		self.blocks_downloaded = 0

		self.am_choking = 1 # our control
		self.am_interested = 0		
		self.peer_choking = 1 # peer control
		self.peer_interested = 0

		self.MESSAGE_ID = {
			0: Peer.process_choke_message,
			1: Peer.process_unchoke_message,
			2: Peer.process_interested_message,
			3: Peer.process_not_interested_message,
			4: Peer.process_have_message,
			5: Peer.process_bitfield_message,
			6: Peer.process_request_message,
			7: Peer.process_piece_message,
			8: Peer.process_cancel_message,
			9: Peer.process_port_message,
			19: Peer.process_handshake_message,
			20: Peer.process_extended_handshake_message,
			255: Peer.process_keep_alive_message
		}

	def init_from_Tracker_Response(self, peer_id_ip_port): ## populates peer's IP n port from string		
		ip_chunk = peer_id_ip_port[:4]
		port_chunk = peer_id_ip_port[4:]
		for index, char in enumerate(ip_chunk): ## parse into xx.xx.xx.xx
			if index != 3:
				self.ip += str(ord(char)) + "."
			else:
				self.ip += str(ord(char))
		self.port = ord(port_chunk[0]) * 256 + ord(port_chunk[1])
		return peer_id_ip_port


	#####################################################
	# major APIs, called by P2P protocol of each peer
	#
	# general flow of Classes :
	#
	# incoming msg (from remote peer) update this peer
	# Torrent updates according to this Peer changes
	# this Peer updates according to Torrent changes
	# P2P Protocol sends new messages generated by Peer
	#
	#####################################################

	def received_messages(self, messages): ## msg handler -> match received msgs w msg parser
		for message in messages: ## array of received messages, self.stream_processor.get_complete_messages()
			self.time_of_last_message = time.time()
			self.MESSAGE_ID[message.get_message_id()](self, message) ## parse msg type -> handler

	def marshall_msgs_to_outgoing_buffer(self): ## msg handler -> create response msgs
		"""
		Request + Interested Msgs to send this peer 
			-> figure out from all Peers what pieces you still need
			-> right now just sequential

		TODO: random first piece + rarest pieces first + end game mode 
			-> when decides Request Msg

		TODO: implements sending outgoing Piece/Block data Message 

		TODO: we need to think re-requests for non-received or corrupted data, again corrupted etc
			  -> blacklist, notify Tracker 
			  -> send another peer for block
		"""
		outgoing_message_buffer = [] ## clear previous outgoing messages

		if self.am_interested == 0: ## previously not interested
			outgoing_message_buffer.append(InterestedMessage()) ## add a "Interested Message" packet to outgoing buffer
			self.am_interested = 1 ## now interested

		## if current piece not finished downloading from this peer + not max out Requests + peer not choke us 
		## -> new Request Msg for remaining datum 
		elif self.current_piece is not None and not self.current_piece.is_complete and \
						len(self.request_buffer) < MAX_OUTSTANDING_REQUESTS and \
						self.peer_choking == 0: 

			while len(self.request_buffer) < MAX_OUTSTANDING_REQUESTS:
				next_begin = self.current_piece.get_next_datum() ## next sub-piece/datum you need
				next_request = RequestMessage(index=self.current_piece.index, begin=next_begin) ## Request Msg

				if not self.current_piece.non_completed_request_exists(next_request): ## Request not existed yet
					outgoing_message_buffer.append(next_request) ## add new Request Msg
					self.request_buffer.append(next_request)
					self.current_piece.add_non_completed_request_index(next_request)
				else: ## Request already exists
					pass		
		self.outgoing_messages_buffer += outgoing_message_buffer
		return outgoing_message_buffer	

	#####################################################
	# message parser + handler
	#
	#####################################################
	def process_bitfield_message(self, new_bitfield_message): 
		# big endian in the BitTorrent protocol
		# P.O.C for ubuntu-16.10-desktop-amd64.iso.torrent
		# 60800 bytes / (20 bytes / piece) = 3040 pieces
		# 3040 pieces / 8 bits per byte  = 380 -> 1 bit represents a piece
		# length of bitfield = 380
		# so each byte of the bitfield represents 8 pieces
		self.received_message_buffer.append(new_bitfield_message)
		self.bitfield.frombytes(new_bitfield_message.bitfield)
		self.bitfield.tolist()

	def process_piece_message(self, new_piece_message): 
		self.received_message_buffer.append(new_piece_message) ## buffer datum from this peer

		for request_message in self.request_buffer: ## expected outstanding request
			if request_message.piece_message_matches_request(new_piece_message): ## we want this datum				
				self.current_piece.append_data(new_piece_message) ## add datum
				self.previous_requests.append(request_message) ## record history
				self.request_buffer.remove(request_message) 

	def process_request_message(self, new_request_message): ## from another peer, index of requested piece
		self.received_message_buffer.append(new_request_message)

	def process_handshake_message(self, new_handshake_message):
		self.received_message_buffer.append(new_handshake_message)
		self.peer_id = new_handshake_message.get_peer_id()
		self.info_hash = new_handshake_message.get_info_hash()
		self.handshake_exchanged = True

	def process_choke_message(self, new_choke_message):
		self.received_message_buffer.append(new_choke_message)
		self.peer_choking = 1

	def process_unchoke_message(self, new_unchoke_message):
		self.received_message_buffer.append(new_unchoke_message)
		self.peer_choking = 0

	def process_interested_message(self, new_interested_message):
		self.received_message_buffer.append(new_interested_message)
		self.peer_interested = 1

	def process_not_interested_message(self, new_not_interested_message):
		self.received_message_buffer.append(new_not_interested_message)
		self.peer_interested = 0

	def process_have_message(self, new_have_message): 
		self.received_message_buffer.append(new_have_message)
		piece_index = new_have_message.get_piece_index()					
		if len(self.bitfield) == 0: ## init if it doesnt yet exist (to avoid bounds accession error)
			for i in range(0, len(self.torrent.pieces_hashes)):
				self.bitfield.append(0)
		self.bitfield[piece_index] = 1

	def process_cancel_message(self, new_cancel_message):
		self.received_message_buffer.append(new_cancel_message)

	def process_port_message(self, new_port_message):
		self.received_message_buffer.append(new_port_message)

	def process_extended_handshake_message(self, message):
		self.received_message_buffer.append(message)

	def process_keep_alive_message(self, new_keepalive_message):
		self.received_message_buffer.append(new_keepalive_message)

	#####################################################
	# helper methods
	#
	#####################################################

	def update_next_piece(self, next_piece): ## next piece == sequantial search bitfield 
		self.blocks_downloaded += 1
		self.current_piece = next_piece
		self.received_message_buffer = []
		self.request_buffer = []
		self.previous_requests = []

	def get_messages_in_window(self, window_in_seconds): ## number of seconds in the past to parse messages from
		current_time = time.time()
		pieces = 0
		for message in self.received_message_buffer:
			if current_time - message.time_of_creation <= 5 and message.get_message_id() == 7:
				pieces += 1
		return pieces ## number of piece messages in the window

	def update_last_contact(self): ## heartbeat -> 2 minutes of inactivity
		pass ## TODO

	def finished_with_piece(self):
		return self.current_piece.is_complete() ## done downloading

	def received_bitfield(self):
		return len(self.bitfield.tolist()) > 0

	def has_piece(self, index): ## true if this Peer's bitfield contains the piece at bitarray[index]
		if len(self.bitfield.tolist()) == 0:
			return False
		else:
			return self.bitfield[index] == 1

	def set_piece(self, piece):
		self.current_piece = piece
